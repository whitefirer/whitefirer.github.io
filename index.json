[{"categories":["Tech"],"content":"细心的朋友可能已经发现我在首页终端上加上了Now you can use the Python directly in this console!这句话，是的，现在python命令已经加入了首页终端中！目前已支持基本库，未来看实际写作需要是否增加其它库的支持，可能会用来做一些分析图形变换显示什么的。 ","date":"2023-04-07","objectID":"/posts/2023/04/07/how-to-run-python-in-the-web-terminal/:0:0","tags":["tech","xterm.js","python","pyodide","wasm"],"title":"如何在页面上跑一个Python终端？","uri":"/posts/2023/04/07/how-to-run-python-in-the-web-terminal/"},{"categories":["Tech"],"content":"背景 之前我在博客里分享过如何使用asciinema来录制终端操作过程并在页面上很轻量级地演示，但是有些例子光看演示还不够，可能还需要实机操作，那么就回到了今天的主题：如何在页面上跑一个python终端（或者任意语言的实操环境）？ ","date":"2023-04-07","objectID":"/posts/2023/04/07/how-to-run-python-in-the-web-terminal/:0:1","tags":["tech","xterm.js","python","pyodide","wasm"],"title":"如何在页面上跑一个Python终端？","uri":"/posts/2023/04/07/how-to-run-python-in-the-web-terminal/"},{"categories":["Tech"],"content":"方案 经过一段时间搜集和分析，发现有以下几种方式： python.org官网的用的方式是通过websocket向在线服务pythonanywhere的远程服务器通讯得到结果的； 菜鸟教程网站和廖雪峰网站里的python教程也都是采用的类似方法，只不过有区别的是直接通过http请求将代码发送到服务器来实现的； katacoda被薅closed了就不提了，其实也是远程服务。 另外，根据原来做过的项目来看，xterm.js也确实能通过websocket连接到docker容器； 但我们注意到他们都有个通病，就是要依赖远程服务，这对于“静态”博客来讲可太不友好了，而且还要保证沙盒的安全。 那有没有不依赖远程服务的方式呢？ 答案是：有！ 比较容易想到的一种方案是在网页上调用起浏览者本机的python，这里就要用到微软开源的node-pty了，具体可以参考它的例子来实现。但是这有个明显的缺点，就是要浏览者事先准备好环境。 那有没有不依赖浏览者环境的方式呢？ 答案依然是：有！ 盘点最近几的技术潮流，我们可以注意到一项技术，那就是webassembly(简称wasm)，完全可以用wasm在页面上跑python代码嘛，还记得之前大火的在web页面执行python代码的项目pyscript吗？它就是基于wasm的接口项目pyodide实现的。 使用也很简单，调用pyodide.runPython就行： \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003ePyodide in xterm.js\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"https://unpkg.com/xterm/css/xterm.css\" /\u003e \u003cscript src=\"https://unpkg.com/xterm@5.1.0/lib/xterm.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdn.jsdelivr.net/pyodide/v0.23.0/full/pyodide.js\"\u003e\u003c/script\u003e \u003cstyle\u003e #terminal { display: flex; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"terminal\"\u003e\u003c/div\u003e \u003cscript\u003e const ENTER = '\\r'; const DEL = '\\u007F'; const VK_UP = '\\x1b[A'; const VK_DOWN = '\\x1b[B'; const VK_RIGHT = '\\x1b[C'; const VK_LEFT = '\\x1b[D'; var pyodide = null; var pythonCodeX = 0; var pythonCodeY = 0; var historyCodeList = []; var lastPythonCodeLine = \"\"; var renderingCode = false; var stdout_codes = []; function rawstdout(code) { stdout_codes.push(code); } var term = new Terminal(); term.open(document.getElementById('terminal')); async function startPyodide() { term.write('Starting Python...'); pyodide = await loadPyodide(); await pyodide.loadPackage(\"pygments\") pyodide.runPythonAsync(` import sys from pygments import highlight from pygments.lexers import PythonLexer from pygments.formatters import TerminalTrueColorFormatter sys.version + ' (https://whitefirer.org)' `).then(output =\u003e { term.write('\\rPython ' + output + '\\r\\n'); term.prompt(); }); pyodide.setStdout({ raw: rawstdout, isatty: true }); } term.prompt = () =\u003e { term.write('\\r\\x1b[01;32m\u003e\u003e\u003e '); }; var pythonCode = ''; var blockFlag = \"\"; var blockMap = { \":\": \"\\r\", \"\\\\\": \"\\r\", \"{\": \"}\", \"[\": \"]\", \"(\": \")\", } var historyIndex = 0; var historyCode = \"\"; var lastCRIndex = 0; function setCursorPosition(x, y) { term.write(`\\x1b[${y};${x}H`) } async function writeHightPythonCode(x, y, pythonCode) { // term.write(e); setCursorPosition(x, y); await pyodide.runPythonAsync(` _PY_code = \"\"\" ${pythonCode.replaceAll(\"\\\\\", \"\\\\\\\\\")} \"\"\" _PY_highlighted_code = highlight(_PY_code, PythonLexer(), TerminalTrueColorFormatter(style='native')); _PY_highlighted_code[:-1] `).then(output =\u003e { term.write(output.replaceAll('\\n', '\\r\\n... ')); }); } function earseCureentLinePythonCode() { if (pythonCodeY === (term.buffer._normal.cursorY + term.buffer._normal.baseY + 1)) { term.write('\\r\\x1b[2K\\x1b[01;32m\u003e\u003e\u003e '); } else if (term.buffer._normal.cursorX \u003e 4) { term.write('\\r\\x1b[2K... '); } else { term.write('\\r\\x1b[2K'); } } term.onData(e =\u003e { const printable = !e.altKey \u0026\u0026 !e.ctrlKey \u0026\u0026 !e.metaKey; switch (e) { case VK_LEFT: if (term.buffer._normal.cursorX \u003e 4) { setCursorPosition(term.buffer._normal.cursorX, term.buffer._normal.cursorY + 1); } break; case VK_RIGHT: lastCRIndex = pythonCode.lastIndexOf('\\r'); lastPythonCodeLine = pythonCode.substring(lastCRIndex + 1, pythonCode.length + 1); if (term.buffer._normal.cursorX \u003c (lastPythonCodeLine.length % term.cols + 4)) { setCursorPosition(term.buffer._normal.cursorX + 2, term.buffer._normal.cursorY + 1); } break; case VK_UP: if (historyCodeList.length === 0) { break; } if (pythonCode.length === 0) { pythonCodeX = term.buffer._normal.cursorX + 1; pythonCodeY = term.buffer._normal.cursorY + term.buffer._normal.baseY + 1; } historyCode = \"\"; historyIndex += 1; if (historyIndex \u003e (historyCodeList.length + 1)) { historyIndex = historyCodeList.length + 1; } else if (historyIndex != (historyCodeList.length + 1)) { historyCode = historyCodeList[historyCodeList.length - historyIndex] } earseCureentLinePythonCode(); lastCRIndex = pythonCode.lastIndexOf('\\r'); pythonC","date":"2023-04-07","objectID":"/posts/2023/04/07/how-to-run-python-in-the-web-terminal/:0:2","tags":["tech","xterm.js","python","pyodide","wasm"],"title":"如何在页面上跑一个Python终端？","uri":"/posts/2023/04/07/how-to-run-python-in-the-web-terminal/"},{"categories":["Tech"],"content":"效果 效果如下，试试在里面敲你熟悉的python代码吧~： ","date":"2023-04-07","objectID":"/posts/2023/04/07/how-to-run-python-in-the-web-terminal/:0:3","tags":["tech","xterm.js","python","pyodide","wasm"],"title":"如何在页面上跑一个Python终端？","uri":"/posts/2023/04/07/how-to-run-python-in-the-web-terminal/"},{"categories":["Tech"],"content":"总结 目前看这个基于wasm技术的方案依赖比较少，但其它方案也不是一无是处，一些复杂环境用远程方案可能更有优势。下次我们再细说wasm和衍生出来的一些技术。 ","date":"2023-04-07","objectID":"/posts/2023/04/07/how-to-run-python-in-the-web-terminal/:0:4","tags":["tech","xterm.js","python","pyodide","wasm"],"title":"如何在页面上跑一个Python终端？","uri":"/posts/2023/04/07/how-to-run-python-in-the-web-terminal/"},{"categories":["Tech"],"content":"背景 如融合、扩展Service Mesh文中所述，为了让第三方服务发现的服务能够接入到Istio服务网格当中，我设计开放一个名为Polaris2Istio的组件。 ","date":"2022-08-30","objectID":"/posts/2022/08/30/polaris2istio/:0:1","tags":["tech","cloud native","service mesh","istio"],"title":"Polaris2Istio的实现和说明","uri":"/posts/2022/08/30/polaris2istio/"},{"categories":["Tech"],"content":"设计图 ","date":"2022-08-30","objectID":"/posts/2022/08/30/polaris2istio/:0:2","tags":["tech","cloud native","service mesh","istio"],"title":"Polaris2Istio的实现和说明","uri":"/posts/2022/08/30/polaris2istio/"},{"categories":["Tech"],"content":"时序图 ","date":"2022-08-30","objectID":"/posts/2022/08/30/polaris2istio/:0:3","tags":["tech","cloud native","service mesh","istio"],"title":"Polaris2Istio的实现和说明","uri":"/posts/2022/08/30/polaris2istio/"},{"categories":["Tech"],"content":"使用方式 编译 make build 运行 polaris2istio --polarisAddress \u003cpolarishost:port\u003e 配置 模式 1. 基于ServiceEntry的管理标签筛选同步Polaris实例: apiVersion: networking.istio.io/v1alpha3 kind: ServiceEntry metadata: name: \u003cpolaris-name-for-k8s\u003e namespace: polaris annotations: aeraki.net/polarisNamespace: Test aeraki.net/polarisService: test-service aeraki.net/external: \"false\" labels: manager: aeraki registry: polaris spec: hosts: - dev.\u003cpolaris-name-for-k8s\u003e.polaris resolution: NONE # or STATIC 详细说明请参考：https://github.com/aeraki-mesh/polaris2istio ","date":"2022-08-30","objectID":"/posts/2022/08/30/polaris2istio/:0:4","tags":["tech","cloud native","service mesh","istio"],"title":"Polaris2Istio的实现和说明","uri":"/posts/2022/08/30/polaris2istio/"},{"categories":["Tech"],"content":"心得技巧 保持分配好的VIP // polaris2istio/pkg/serviceregistry/polaris/watcher/provider.go func (w *ProviderWatcher) syncPolarisServices2Istio(polarisInfo *model.PolarisInfo) { klog.Infof(\"[syncPolarisServices2Istio] polarisInfo: %v\", polarisInfo) rsp, err := w.polarisclient.GetPolarisAllInstances(polarisInfo.PolarisNamespace, polarisInfo.PolarisService) if err != nil { klog.Errorf(\"[syncPolarisServices2Istio] query polaris services' instances failed, err: %v\", err.Error()) return } newServiceEntry, newAnnotations := model.ConvertServiceEntry(rsp, polarisInfo) if newServiceEntry == nil { klog.Errorf(\"convertServiceEntry failed?\") return } oldServiceEntry, err := w.ic.NetworkingV1alpha3().ServiceEntries(w.configRootNS).Get(context.TODO(), model.CovertServiceName(polarisInfo.PolarisNamespace, polarisInfo.PolarisService), v1.GetOptions{}) if err != nil { klog.Infof(\"[syncPolarisServices2Istio] get old service entries failed, error: %v\", err) return } newServiceEntry.Addresses = append(newServiceEntry.Addresses, oldServiceEntry.Spec.GetAddresses()...) if revision, exists := oldServiceEntry.GetAnnotations()[\"aeraki.net/revision\"]; !exists || newAnnotations[\"aeraki.net/revision\"] != revision { klog.Infof(\"[syncPolarisServices2Istio] update serviceentry: %v\", newServiceEntry) _, err = w.ic.NetworkingV1alpha3().ServiceEntries(oldServiceEntry.Namespace).Update(context.TODO(), w.toServiceEntryCRD(model.CovertServiceName(polarisInfo.PolarisNamespace, polarisInfo.PolarisService), newServiceEntry, oldServiceEntry, newAnnotations), v1.UpdateOptions{FieldManager: aerakiFieldManager}) if err != nil { klog.Errorf(\"failed to update ServiceEntry: %s\", err.Error()) } } else { log.Infof(\"[syncPolarisServices2Istio] serviceentry unchanged: %v\", oldServiceEntry.GetName()) } } 代码 ","date":"2022-08-30","objectID":"/posts/2022/08/30/polaris2istio/:0:5","tags":["tech","cloud native","service mesh","istio"],"title":"Polaris2Istio的实现和说明","uri":"/posts/2022/08/30/polaris2istio/"},{"categories":["Tech"],"content":"注意事项 只对polaris命名空间中的ServiceEntrys同步； 在集群中运行时需要为其配置权限策略； 开源版本的polaris sdk是需要手动设置polaris地址的，与内部版不同； ","date":"2022-08-30","objectID":"/posts/2022/08/30/polaris2istio/:0:6","tags":["tech","cloud native","service mesh","istio"],"title":"Polaris2Istio的实现和说明","uri":"/posts/2022/08/30/polaris2istio/"},{"categories":["Tech"],"content":" 导语 没有最完美的架构，只有最合适的架构。 ","date":"2022-08-29","objectID":"/posts/2022/08/29/extension-and-expansion-of-service-mesh/:0:0","tags":["tech","cloud native","service mesh"],"title":"融合、扩展Service Mesh","uri":"/posts/2022/08/29/extension-and-expansion-of-service-mesh/"},{"categories":["Tech"],"content":"背景 很多时候服务网格在业务难以落地，往往是因为有历史包袱或者特殊需求，反而没有新设计的项目接入服务网格容易，而原因多是以下几点： 难点 私有协议：这里泛指Istio官方未支持的协议，如果不能识别私有协议，也就无法对私有协议进行流量管理（如路由等）； 不能很好地平滑过渡掉原有的北极星或者Consul服务发现； 第三方服务发现：比如北极星服务发现得到的IP是实例IP，我们这边要想办法让流量走到ServiceIP上去，通过Virtual Service IP加端口来确定服务和协议，才能利用到边车来管理流量和解析自定义协议； ","date":"2022-08-29","objectID":"/posts/2022/08/29/extension-and-expansion-of-service-mesh/:0:1","tags":["tech","cloud native","service mesh"],"title":"融合、扩展Service Mesh","uri":"/posts/2022/08/29/extension-and-expansion-of-service-mesh/"},{"categories":["Tech"],"content":"解决方案 私有协议 私有协议服务网格的解决方案大概有以下两种 协议转换 协议扩展 协议转换 协议转换顾名思议就是将协议转换成网格内支持的方案。 一种是在client多实现个协议转换层，但开发以及部署更新麻烦，但如gRPC-gateway也是种实现方式，只不过gRPC在Istio本身就支持； 一种是在边车、adapter或者边缘网关服务去做转换，但一样有上面的问题； 且有可能目前网格内的协议并不合适业务场景，比如性能下降等问题； 协议扩展 这里的协议扩展是指通过Service Mesh来扩展支持私有协议及任意的尚未支持的协议。 自研 自研肯定是能实现的，但对技术要求较高，需要要对数据面修改的技术能力，像Envoy是用C++实现的，另外控制面也要做一定修改。 Aeraki Aeraki Mesh可以帮助你在服务网格中管理任何七层协议。目前已经支持了 Dubbo、Thrit、Redis、Kafka、ZooKeeper 等开源协议。你还可以使用 Aeraki Mesh 提供的 MetaProtocol 协议扩展框架来管理私有协议的七层流量。 /** * Codec for Awesomerpc protocol. */ class AwesomerpcCodec : public MetaProtocolProxy::Codec, public Logger::Loggable\u003cLogger::Id::misc\u003e { public: AwesomerpcCodec() {}; ~AwesomerpcCodec() override = default; //协议解码，需要解析 buffer 并填充 Metadata， Metadata 将被用于 MetaProtocol Proxy 的 filter，例如限流，路由的匹配条件 MetaProtocolProxy::DecodeStatus decode(Buffer::Instance\u0026 buffer, MetaProtocolProxy::Metadata\u0026 metadata) override; //协议编码，可以根据 Mutation 对请求或者响应数据包进行修改，例如增加、删除或者修改 header，修改后需要回写到 buffer 中 void encode(const MetaProtocolProxy::Metadata\u0026 metadata, const MetaProtocolProxy::Mutation\u0026 mutation, Buffer::Instance\u0026 buffer) override; //错误编码，用于框架向客户端返回错误信息，例如未找到路由或者连接创建失败等，编码的数据需要写入到 buffer 中 void onError(const MetaProtocolProxy::Metadata\u0026 metadata, const MetaProtocolProxy::Error\u0026 error, Buffer::Instance\u0026 buffer) override; ... 实现编解码接口较简单，仅需实现 decode，encode 和 onError 三个方法即可。 而其它服务治理能力都已经通过MetaPortocol这个EnvoyFilter，以插件的形式统一实现了支持。 而在Istio中声明使用它也较简单，仅需创建一个 Aeraki 的 ApplicationProtocol CRD资源： apiVersion: metaprotocol.aeraki.io/v1alpha1 kind: ApplicationProtocol metadata: name: my-protocol namespace: istio-system spec: protocol: my-protocol codec: aeraki.meta_protocol.codec.my_protocol 第三方服务发现 几种融合网格服务发现名字的方案对比： 方案名 优点 缺点 基于服务发现代理 完全不需要修改业务代码 需要开发代理服务 基于边车 更符合后面网格建设的规范 能处理自定义协议 需要修改业务请求Client 在边车中进行服务发现较重 基于配置 原理较为简单 需要修改业务请求Client 不够灵活，不够通用 基于DNS 原理较为简单，易维护 需要修改业务请求Client DNS+边车 原理较为简单，易维护 能处理自定义协议 需要修改业务请求Client 服务发现改成非k8s service 可以照顾原有VM上的服务 需要自研控制面，数据面也要进行一些修改 我个人比较喜欢的是代理、DNS和用Consul替代的这三种方案，其中最符合istio原有流程是DNS这种，方案过多，就不一一详细说明了，这里主要提DNS模式下，通过X2Istio注册ServiceEntry的方式。 X2Istio (Polaris2Istio) Istio可用特性 ServiceEntry自动分配VIP； Service ExternalName提供DNS CNAME记录； 利用上述特性可制定以下方案： 说明 走方式4调用将上报给Polaris组件以供他自动建立新的ServiceEntry，这样就回到了方式3，后面就不用再进行L5发现而是直接DNS解析走ServiceIP了； 走方式3调用的服务如果后面迁移到了集群内，那么将externalName改成集群内的Service，后面变成方式2，这样就可以具备完整的网格能力； 当主调都改成直接使用ServiceName时，将都走方式1，有其它几种调用方式的存在，将大大降低业务改造的工作量。 图中的Polaris2Istio就相当于本图中的X2Istio。 Polaris2Istio: https://github.com/aeraki-mesh/polaris2istio ServiceEntry自动分配IP并解析 DNS 代理还支持为没有明确定义的 ServiceEntry 自动分配地址。这是通过 ISTIO_META_DNS_AUTO_ALLOCATE 选项配置的。 启用此特性后，DNS 响应将为每个 ServiceEntry 自动分配一个不同的独立地址。然后代理能匹配请求与 IP 地址，并将请求转发到相应的 ServiceEntry。 参考：https://istio.io/latest/zh/docs/ops/configuration/traffic-management/dns-proxy/ DNS解析 DNS是k8s内部就在使用的名字解析服务（目前集群中使用的是CoreDNS），我们只要解决名字转义后的域名能够一样解析到ServiceIP就能解决服务发现的问题，这里可以利用Service本身就有EnternalName来CNAME解析解决。 参考：https://github.com/kubernetes/kubernetes/issues/39792 externalname 参考：https://kubernetes.io/docs/concepts/services-networking/service/#externalname ServiceEntry 可按如下配置： apiVersion: networking.istio.io/v1alpha3 kind: ServiceEntry metadata: name: \u003cpolaris-name-for-k8s\u003e namespace: polaris annotations: aeraki.net/polarisNamespace: Test aeraki.net/polarisService: test-service aeraki.net/external: \"false\" labels: manager: aeraki registry: polaris spec: hosts: - dev.\u003cpolaris-name-for-k8s\u003e.polaris resolution: NONE # or STATIC 参考： https://github.com/aeraki-mesh/polaris2istio 请注意我们集群当中使用的是CoreDNS，它要求externalName的格式必须是符合FQDN的，即最全的形式。 对于已经在集群当中的Service，只需要创建有原服务发现名字和service映射关系的externalName类型的Service就行； 对于不在集群当中的L5服务，则需要先创建ServiceEntry按入网格，并通过Polaris2Istio来维护实例变更； 由于各项目不一样，源码中没有根据管理的Service来匹配，而是直接创建相应的ServiceEntry即可。 关于Polaris的具体实现，下篇文章再讲。 ","date":"2022-08-29","objectID":"/posts/2022/08/29/extension-and-expansion-of-service-mesh/:0:2","tags":["tech","cloud native","service mesh"],"title":"融合、扩展Service Mesh","uri":"/posts/2022/08/29/extension-and-expansion-of-service-mesh/"},{"categories":["Tech"],"content":"总结 现实情况不总是理想模型，我们要根据实际情况进行调整，没有最完美的架构，只有最合适的架构。 ","date":"2022-08-29","objectID":"/posts/2022/08/29/extension-and-expansion-of-service-mesh/:0:3","tags":["tech","cloud native","service mesh"],"title":"融合、扩展Service Mesh","uri":"/posts/2022/08/29/extension-and-expansion-of-service-mesh/"},{"categories":["Tech","Workspace"],"content":"工欲善其事，必先利其器","date":"2022-08-29","objectID":"/posts/2022/08/29/efficient-command-line-tools/","tags":["tech","command-line-tools"],"title":"高效终端命令行工具","uri":"/posts/2022/08/29/efficient-command-line-tools/"},{"categories":["Tech","Workspace"],"content":" 导语 工欲善其事，必先利其器。 作为技术人员，一个高效的工作环境尤为重要。下面分享下我的终端命令行下的环境和工具配置。 zsh\u0026oh-my-zsh 安装 参考：https://ohmyz.sh/ 插件 语法高亮（zsh-syntax-highlighting） git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 自动补全（zsh-autosuggestions） git clone https://github.com/zsh-users/zsh-autosuggestions.git $ZSH_CUSTOM/plugins/zsh-autosuggestions 最后记得将它们加到.zshrc里。 集群环境显示（zsh-kubectl-prompt) 可参考https://github.com/whitefirer/workspace/blob/main/.zshrc进行配置： # .zshrc function right_prompt() { local color=\"blue\" if [[ \"$ZSH_KUBECTL_NAMESPACE\" =~ \"system\" ]]; then color=\"yellow\" fi if [[ \"$ZSH_KUBECTL_CONTEXT\" =~ \"desktop\" || \"$ZSH_KUBECTL_CONTEXT\" =~ \"dev\" ]]; then color=\"green\" fi if [[ \"$ZSH_KUBECTL_CONTEXT\" =~ \"prod\" ]]; then color=\"red\" fi echo \"%{$terminfo[bold]$fg[$color]%}\\u2638($ZSH_KUBECTL_PROMPT)%{$reset_color%}\" } RPROMPT='$(right_prompt)' 成功后会显示如下： 其中cni-test为自己在kubeconfig中给context取的名字，可自行修改。 里面的ctx和ns均为krew插件。 kubectl备忘录 kubectl安装\u0026操作 其它可参考：https://kubernetes.io/docs/tasks/tools/#install-kubectl 更多相关备忘：https://kubernetes.io/zh/docs/reference/kubectl/cheatsheet/ kubectl插件（krew） 参考：https://krew.sigs.k8s.io/ kubectl高亮（kubecolor） 可以参考https://github.com/hidetatz/kubecolor readme里的做法，alias成k或者kubectl。 其它 终端复用（tmux） GitHub：https://github.com/tmux/tmux 参考：https://www.ruanyifeng.com/blog/2019/10/tmux.html 高级cat（bat) 参考：https://github.com/sharkdp/bat/blob/master/doc/README-zh.md 高级模糊查找（fzf） 参考：https://github.com/junegunn/fzf#preview-window 右侧的预览是结合了前面的bat命令。 高级ls（exa） 安装 参考：https://github.com/ogham/exa 高级top（htop） 安装 brew install htop json高亮（jq） brew install jq json高亮及折叠（fx） 安装 brew install fx 官网 https://github.com/antonmedv/fx yaml高亮（yh） 当然有使用kubecolor的话，kubectl也用不上yh，但是其它命令场景还是可以用的。 安装 brew install yh ","date":"2022-08-29","objectID":"/posts/2022/08/29/efficient-command-line-tools/:0:0","tags":["tech","command-line-tools"],"title":"高效终端命令行工具","uri":"/posts/2022/08/29/efficient-command-line-tools/"},{"categories":["Hugo"],"content":"Asciinema-Player是一款著名的的终端录制播放器，可用于播放asciinema录制的播放文件，经常被用来进行终端操作演示。这里也将其引入到了当前Hugo博客中使用，下面我将讲讲引入的过程。 ","date":"2022-08-28","objectID":"/posts/2022/08/28/hugo-asciinema-player/:0:0","tags":["hugo","tech","asciinema"],"title":"如何在Hugo博客中使用终端播放器Asciinema-Player","uri":"/posts/2022/08/28/hugo-asciinema-player/"},{"categories":["Hugo"],"content":"1.效果展示 Talk is cheap, show the result ~ 这里直接借用官方demo进行展示。 ","date":"2022-08-28","objectID":"/posts/2022/08/28/hugo-asciinema-player/:0:1","tags":["hugo","tech","asciinema"],"title":"如何在Hugo博客中使用终端播放器Asciinema-Player","uri":"/posts/2022/08/28/hugo-asciinema-player/"},{"categories":["Hugo"],"content":"2.需求分析 为什么需要在Hugo里面使用终端播放器Asciinema-Player呢？ 作为技术人员，在写博客时总是需要进行一些终端操作演示，而演示方式无非以下几种： 方式 优点 缺点 视频 能配音配特效 网站流量消耗大，不能复制文本 动图 文件相对小些 不能控制进度，不能复制文本 代码 占用流量小，能复制 不能控制进度，也不太好展示效果 而终端录制播放器Asciinema-Player则兼容体积小、能控制、能复制于一体并能完美复现终端操作场景，非常适合用于在博客中进行一些终端操作演示。 ","date":"2022-08-28","objectID":"/posts/2022/08/28/hugo-asciinema-player/:0:2","tags":["hugo","tech","asciinema"],"title":"如何在Hugo博客中使用终端播放器Asciinema-Player","uri":"/posts/2022/08/28/hugo-asciinema-player/"},{"categories":["Hugo"],"content":"3.解决方案 首先，在网上找下前人在Hugo博客里扩展嵌入asciinema-player的方法，比如 Embedding asciinema cast in your Hugo site。 shortcode 可以找到里面asciinema-player的shortcode代码如下： \u003cp\u003e \u003casciinema-player src=\"/casts/{{ with .Get \"key\" }}{{ . }}{{ end }}.cast\" cols=\"{{ if .Get \"cols\" }}{{ .Get \"cols\" }}{{ else }}640{{ end }}\" rows=\"{{ if .Get \"rows\" }}{{ .Get \"rows\" }}{{ else }}10{{ end }}\" {{ if .Get \"autoplay\" }}autoplay=\"{{ .Get \"autoplay\" }}\"{{ end }} {{ if .Get \"preload\" }}preload=\"{{ .Get \"preload\" }}\"{{ end }} {{ if .Get \"loop\" }}loop=\"{{ .Get \"loop\" }}\"{{ end }} start-at=\"{{ if .Get \"start-at\" }}{{ .Get \"start-at\" }}{{ else }}0{{ end }}\" speed=\"{{ if .Get \"speed\" }}{{ .Get \"speed\" }}{{ else }}1{{ end }}\" {{ if .Get \"idle-time-limit\" }}idle-time-limit=\"{{ .Get \"idle-time-limit\" }}\"{{ end }} {{ if .Get \"poster\" }}poster=\"{{ .Get \"poster\" }}\"{{ end }} {{ if .Get \"font-size\" }}font-size=\"{{ .Get \"font-size\" }}\"{{ end }} {{ if .Get \"theme\" }}theme=\"{{ .Get \"theme\" }}\"{{ end }} {{ if .Get \"title\" }}title=\"{{ .Get \"title\" }}\"{{ end }} {{ if .Get \"author\" }}author=\"{{ .Get \"author\" }}\"{{ end }} {{ if .Get \"author-url\" }}author-url=\"{{ .Get \"author-url\" }}\"{{ end }} {{ if .Get \"author-img-url\" }}author-img-url=\"{{ .Get \"author-img-url\" }}\"{{ end }} \u003e\u003c/asciinema-player\u003e \u003c/p\u003e 细细口味了下这段代码，结合自己需求进行了修改： Talk is cheap, show me the code ~ # themes/iLoveIt/layouts/shortcodes/asciinema.html \u003cp\u003e \u003casciinema-player {{- with .Get \"src\" }} src=\"{{ . }}\" {{ end -}} {{- with .Get \"key\" }} src=\"/casts/{{ . }}.cast\"{{ end -}} cols=\"{{ if .Get \"cols\" }}{{ .Get \"cols\" }}{{ else }}640{{ end }}\" rows=\"{{ if .Get \"rows\" }}{{ .Get \"rows\" }}{{ else }}10{{ end }}\" {{- with .Get \"autoplay\" }}autoplay=\"{{ . }}\"{{ end -}} {{- with .Get \"preload\" }}preload=\"{{ . }}\"{{ end -}} {{- with .Get \"loop\" }}loop=\"{{ . }}\"{{ end -}} start-at=\"{{ if .Get \"start-at\" }}{{ .Get \"start-at\" }}{{ else }}0{{ end }}\" speed=\"{{ if .Get \"speed\" }}{{ .Get \"speed\" }}{{ else }}1{{ end }}\" {{- with .Get \"idle-time-limit\" }}idle-time-limit=\"{{ . }}\"{{ end -}} {{- with .Get \"poster\" }} poster=\"{{ . | safeURL }}\"{{ end -}} {{- with .Get \"font-size\" }}font-size=\"{{ . }}\"{{ end -}} {{- with .Get \"theme\" }}theme=\"{{ . }}\"{{ end -}} {{- with .Get \"title\" }}title=\"{{ . }}\"{{ end -}} {{- with .Get \"author\" }}author=\"{{ . }}\"{{ end -}} {{- with .Get \"author-url\" }}author-url=\"{{ . }}\"{{ end }} {{- with .Get \"author-img-url\" }}author-img-url=\"{{ . }}\"{{ end -}} fit=\"{{ if .Get \"fit\" }}{{ .Get \"fit\" }}{{ else }}width{{ end }}\" \u003e\u003c/asciinema-player\u003e {{- .Page.Scratch.SetInMap \"this\" \"asciinema\" true -}} \u003c/p\u003e 注意看高亮部分，主要修改了以下几点： 修改点 if .Get 形式代码过于累赘，这里把不需要取默认值的语句统统改成了with .Get形式； 只有固定的key方法从本站获取.cast录制文件，这里扩展了src以便从站外获取录制文件地址； poster这里会得到一个奇怪的数据#ZgotmplZ，它是一个安全防护的默认数据，见官方说明，会导致设置指定时间封面无效，解决起来也简单，加上| safeURL管道方法就可解决； js、css 参考方案里动态引入js和css，用到的该播放器的文章里需设置asciinema为true： {{ if .Params.asciinema }} \u003cscript src=\"{{ .Site.BaseURL }}js/asciinema-player.js\"\u003e\u003c/script\u003e {{ end }} --- title: Kubernetes Backup - ARK description: Kubernetes backup process using ark asciinema: true tags: - kubernetes - backup --- 可以看到上面是通过在文章里加asciinema参数实现的js、css资源动态加载，其实可以参考其它如mermaid的接入方式，直接在渲染时置标记就好： # themes/iLoveIt/layouts/partials/assets.html {{- /* asciinema */ -}} {{- if (.Scratch.Get \"this\").asciinema | or $params.draft -}} {{- $source := \"lib/asciinema/asciinema-player.min.css\" -}} {{- dict \"Source\" $source \"Fingerprint\" $fingerprint | dict \"Scratch\" .Scratch \"Data\" | partial \"scratch/style.html\" -}} {{- $source := \"lib/asciinema/asciinema-player.min.js\" -}} {{- dict \"Source\" $source \"Fingerprint\" $fingerprint | dict \"Scratch\" .Scratch \"Data\" | partial \"scratch/script.html\" -}} {{- end -}} 其中$params.draft是为了开发模式下也能设置草稿参数进行预览: # themes/iLoveIt/assets/data/cdn/jsdelivr.yml gitalkJS: gitalk@1.7.2/dist/gitalk.min.js # valine@1.5.0 https://valine.js.org/ valineJS: valine@1.5.0/dist/Valine.min.js asciinemaJS: asciinema-player@3.0.1/dist/index.min.js # cookieconsent@3.1.1 https://github.com/osano/cookieconsent cookieconsentCSS: cookieconsent@3.1.1/build/cookiecons","date":"2022-08-28","objectID":"/posts/2022/08/28/hugo-asciinema-player/:0:3","tags":["hugo","tech","asciinema"],"title":"如何在Hugo博客中使用终端播放器Asciinema-Player","uri":"/posts/2022/08/28/hugo-asciinema-player/"},{"categories":["Hugo"],"content":"4.使用方法 asciinema-player asciinema-player即播放器，在博客中使用只需简单在文章中加入以下代码： 其中，cols、rows分别为行列，preload则是要不要预加载，poster则是封面，有data模式也有npt模式，npt即按时间截取封面，上面的就是截取55秒时的终端作为封面。 另外还有speed：播放速度，autoplay：自动播放等参数，具体可参考asciinema-player设置 呈现效果如下（借用了helix-editor的演示，文件大些可能加载慢些）： 点击播放按钮播放，可拖动进度条或者使用方向键控制播放进度。 asciinema 上述终端播放所使用的cast文件，都是使用asciinema在终端录制的。 安装 brew install asciinema 使用 ➜ ~ asciinema --help usage: asciinema [-h] [--version] {rec,play,cat,upload,auth} ... Record and share your terminal sessions, the right way. positional arguments: {rec,play,cat,upload,auth} rec Record terminal session play Replay terminal session cat Print full output of terminal session upload Upload locally saved terminal session to asciinema.org auth Manage recordings on asciinema.org account options: -h, --help show this help message and exit --version show program's version number and exit example usage: Record terminal and upload it to asciinema.org: asciinema rec Record terminal to local file: asciinema rec demo.cast Record terminal and upload it to asciinema.org, specifying title: asciinema rec -t \"My git tutorial\" Record terminal to local file, limiting idle time to max 2.5 sec: asciinema rec -i 2.5 demo.cast Replay terminal recording from local file: asciinema play demo.cast Replay terminal recording hosted on asciinema.org: asciinema play https://asciinema.org/a/difqlgx86ym6emrmd8u62yqu8 Print full output of recorded session: asciinema cat demo.cast For help on a specific command run: asciinema \u003ccommand\u003e -h 另外如果想将其转化为gif动图，也可以使用asciicast2gif。 ","date":"2022-08-28","objectID":"/posts/2022/08/28/hugo-asciinema-player/:0:4","tags":["hugo","tech","asciinema"],"title":"如何在Hugo博客中使用终端播放器Asciinema-Player","uri":"/posts/2022/08/28/hugo-asciinema-player/"},{"categories":["Hugo"],"content":"5.总结 通过以上实践，虽然过程有些曲折，但最终还是顺利地将asciinema-player终端播放器引入到了hugo中使用，后续发布的博客也将经常见到其身影。 ","date":"2022-08-28","objectID":"/posts/2022/08/28/hugo-asciinema-player/:0:5","tags":["hugo","tech","asciinema"],"title":"如何在Hugo博客中使用终端播放器Asciinema-Player","uri":"/posts/2022/08/28/hugo-asciinema-player/"},{"categories":null,"content":"个人简介 姓名：王诚强 昵称：whitefirer、mortywang、strcat、一只流浪猫 🔭 我正在 腾讯 工作，研究并开发基础架构、云原生、服务网格，同时是Aeraki-Mesh的Maitainer； 🌱 我正在努力学习以成为优秀的 云原生开发者、 基础架构工程师、 架构师、技术管理者； 👯 我热衷为伟大的项目积极做出贡献，或者说想创造伟大的项目； 💬 可以与我一起探讨 云原生 、 架构设计、乃至一切 有趣的技术 😄； ⚡ 显而易见: 我是一名 GEEK； 联系方式：发邮件给我 或者以下方式↓ ","date":"2022-08-21","objectID":"/about/:0:1","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"演讲和讲义 OpenTalk演讲：荔枝微课基础架构的演进与实践 腾讯云云原生大会：荔枝微课基于 Kubernetes 搭建分布式压测系统 IstioCon 2022分享: Istio + Aeraki 在腾讯音乐的服务网格落地 ","date":"2022-08-21","objectID":"/about/:0:2","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"荣誉 🏆 2020年荣获荔枝微课S级贡献员工称号（公司级最高荣誉） 🏆 2022年腾讯新代码文化团队金奖（集团公司级，Aeraki Mesh Team） 🥇 2022年腾讯新代码文化个人奖（集团公司级，每团队一名额，Aeraki Mesh Maintainer） ","date":"2022-08-21","objectID":"/about/:0:3","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"自我评价 十年从业经验，阅历丰富，有着创业经历，现在腾讯音乐国际业务部这边负责基础架构，包括云原生和服务网格，更早是在荔枝微课担任基础架构负责人(直接汇报CTO)，落地了k8s集群和istio服务网格在内的云原生架构，并负责开发了配置中心、DevOps平台和分布式压测系统等一系列基础平台。从0到1实现了云原生和基础架构改造，也从0到1搭建过团队，并富有创造力，能够从全局出发考虑问题，抓住稳定和高效的重点，并实际推进落地，具有Geek精神，对新技术保持学习热情，关注CNCF社区的发展，热衷于开源事业，学习并参与开源项目的开发，不断在与他人的交流中获得灵感共同进步。 编程语言 开发框架 数据库\u0026组件 常用工具 休闲平台 操作系统 ","date":"2022-08-21","objectID":"/about/:0:4","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"微信扫码 ","date":"2022-08-21","objectID":"/about/:0:5","tags":null,"title":"关于我","uri":"/about/"},{"categories":["Tech","Hugo"],"content":"背景 ","date":"2022-08-13","objectID":"/posts/2022/08/13/how-to-settingup-blog-with-hugo-github-netlify/:0:1","tags":["tech","hugo","github","netlify"],"title":"如何使用Hugo+Github+Netlify搭建博客","uri":"/posts/2022/08/13/how-to-settingup-blog-with-hugo-github-netlify/"},{"categories":["Tech","Hugo"],"content":"方案 通过配置 Github Action 来编译构建我们的网站文件并发布到 Github Pages 。 与此同时，通过 Netlify 监听 Github 仓库的变化，同步更新部署到 Netlify App 网站。 当然其中每个步骤都可以替换或同时有其它方式，如流水线也可以用circleci之类的，网站托管也可以用nginx服务器、SCF云函数、OSS对象存储等方式。 构建流水线（Github Action） Github Action 的 workflows 配置文件如下： # mysite/.github/workflows/build-and-sync-website.yml name: build on: # 触发时机 workflow_dispatch: # 手动触发 push: # 代码提交触发 branches: # 在哪个分支 - main # 在main分支 pull_request: # PR提交时触发 jobs: # 工作流 build: # 工作名称 runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \"latest\" extended: true - name: Build Web run: hugo -v --gc - name: Deploy Web to Github Pages uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.BLOG_TOKEN }} EXTERNAL_REPOSITORY: whitefirer/whitefirer.github.io PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} # - uses: manyuanrong/setup-ossutil@v2.0 # with: # # endpoint 可以去oss控制台上查看 # endpoint: \"oss-cn-hongkong.aliyuncs.com\" # # 使用我们之前配置在secrets里面的accesskeys来配置ossutil # access-key-id: ${{ secrets.ACCESS_KEY_ID }} # access-key-secret: ${{ secrets.ACCESS_KEY_SECRET }} # - name: Deply Web To OSS # run: ossutil cp public oss://blog-whitefirer/ -rf 徽章（Badge） [![Netlify Status](https://api.netlify.com/api/v1/badges/8aeed089-7b2c-4ebe-84e9-8df704f39948/deploy-status)](https://app.netlify.com/sites/whitefirer/deploys) [![GitHub](https://github.com/whitefirer/mysite/actions/workflows/build-and-sync-website.yml/badge.svg)](https://github.com/whitefirer/mysite/actions/workflows/build-and-sync-website.yml) 效果如下： 可以通过观测显示的样式来确认网站更新状态，也可以点击徽章后查看构建和发布的日志详情。 HTTPS域名证书（Let’s Encrypt CA） 域名证书这里用的免费证书，当然也可以购买证书。 ","date":"2022-08-13","objectID":"/posts/2022/08/13/how-to-settingup-blog-with-hugo-github-netlify/:0:2","tags":["tech","hugo","github","netlify"],"title":"如何使用Hugo+Github+Netlify搭建博客","uri":"/posts/2022/08/13/how-to-settingup-blog-with-hugo-github-netlify/"},{"categories":["Tech","Hugo"],"content":"总结 整个方案较简单，维护起来也容易，每次变更通过Git提交即可自动触发构建部署。 后面有时间了我再分享下网站功能和主题的开发扩展。 ","date":"2022-08-13","objectID":"/posts/2022/08/13/how-to-settingup-blog-with-hugo-github-netlify/:0:3","tags":["tech","hugo","github","netlify"],"title":"如何使用Hugo+Github+Netlify搭建博客","uri":"/posts/2022/08/13/how-to-settingup-blog-with-hugo-github-netlify/"},{"categories":["Tech"],"content":" 导语 本文根据2021年4月10日深圳站举办的【腾讯云原生技术开放日】 线下活动中，荔枝微课基础架构负责人王诚强关于“基于 kubernetes 搭建分布式压测系统”的演讲整理而成。 大家好，今天想和大家分享的主题是基于 kubernetes 搭建分布式压测系统。从背景、原理、实现、效果和未来方向5个方面讲解了荔枝微课在基于 kubernetes 搭建分布式压测系统上的实践和思考。 ","date":"2021-04-13","objectID":"/posts/2021/04/13/building-a-distributed-pressure-testing-system-based-on-kubernetes/:0:0","tags":["tech","cloud native"],"title":"荔枝微课基于 kubernetes 搭建分布式压测系统","uri":"/posts/2021/04/13/building-a-distributed-pressure-testing-system-based-on-kubernetes/"},{"categories":["Tech"],"content":"背景 荔枝微课作为一个高速发展的平台，面临着业务流量越来越大的冲击，特别是在去年疫情期间遭遇成倍流量增长的情况，是通过什么方式轻松渡过难关的？以我在荔枝微课落地云原生的经历来说，为什么我们要去实践云原生架构呢？只是因为它是业内技术趋势吗？ 其实这是源于业务需要的，基础架构最重要的是稳定高效，在我最早接手并负责荔枝微课基础架构时，第一个季度的目标居然是应急响应，但我们都知道应急响应是治标不治本的，而要治本根治的话那么就要对改掉整个底层基础架构，这也是为什么荔枝微课会去做云原生实践的原因。 而在做这个实践的时候，我们还需要一个工具来衡量，那就是分布式压测系统。我们早期使用过本地压测、CVM 伸缩组压测等方案，但是他们有着本地资源能力有限、伸缩组申请变更麻烦、伸缩速度较慢、压测脚本和报告管理混乱，经常无存档等缺点。于是我们采用了现在的基于 kubernetes 的分布式压测方案。 ","date":"2021-04-13","objectID":"/posts/2021/04/13/building-a-distributed-pressure-testing-system-based-on-kubernetes/:0:1","tags":["tech","cloud native"],"title":"荔枝微课基于 kubernetes 搭建分布式压测系统","uri":"/posts/2021/04/13/building-a-distributed-pressure-testing-system-based-on-kubernetes/"},{"categories":["Tech"],"content":"分布式压测方案借助的三个技术 原理上来讲，需要借助三方面的技术： 编程技术 这里我们选择了我们团队较熟悉的 python，不同团队可以有不同的选择。 压测引擎 我们用的是 Locust，因为它是用 python 写脚本，其实也可以更换成 jmeter 之类的其它压测引擎。 kubernetes 主要利用它的服务编排技术来进行一个资源上的调度，经过我们测试，如果是普通集群，在需要弹出集群物理节点的情况下，全部就绪需要90秒，但是使用弹性集群，则可以压缩到15~20秒，所以推荐使用弹性集群。 ","date":"2021-04-13","objectID":"/posts/2021/04/13/building-a-distributed-pressure-testing-system-based-on-kubernetes/:0:2","tags":["tech","cloud native"],"title":"荔枝微课基于 kubernetes 搭建分布式压测系统","uri":"/posts/2021/04/13/building-a-distributed-pressure-testing-system-based-on-kubernetes/"},{"categories":["Tech"],"content":"整体框架 整个技术框架原理上，压测节点分为主节点（master）、从节点 （slave）和监控节点（monitor）三种类型： 主节点 负责任务管理和数据采集聚合，本身不进行压测任务 从节点 负责压测任务 监控节点 从主节点将结果通过 webhook 传递给 web 服务处理端； 另外这些节点的状态、日志都会通过 K8s 的 api 进行采集。根据压测任务里主从节点所申请的资源，集群将提前伸缩好节点，并将任务分配到不同节点，以达到动态提高压测能力的目的。 ","date":"2021-04-13","objectID":"/posts/2021/04/13/building-a-distributed-pressure-testing-system-based-on-kubernetes/:0:3","tags":["tech","cloud native"],"title":"荔枝微课基于 kubernetes 搭建分布式压测系统","uri":"/posts/2021/04/13/building-a-distributed-pressure-testing-system-based-on-kubernetes/"},{"categories":["Tech"],"content":"压测流程 右边为用户所感知到的过程，压测集中包括多个压测场景，通过编写压测脚本和配置压测参数的方式生成压测任务，并最终生成压测报告。 左边为 python 控制集群来生成任务的过程，具体是渲染生成不同任务的yaml 文件后，生成相应的 job pod，然后持续将 pod 状态 、日志和压测曲线结果反馈在页面上。 整个过程所使用的技术并没有多高深，主要是在集群应用上的一种探索。 ","date":"2021-04-13","objectID":"/posts/2021/04/13/building-a-distributed-pressure-testing-system-based-on-kubernetes/:0:4","tags":["tech","cloud native"],"title":"荔枝微课基于 kubernetes 搭建分布式压测系统","uri":"/posts/2021/04/13/building-a-distributed-pressure-testing-system-based-on-kubernetes/"},{"categories":["Tech"],"content":"实现方法 使用 yaml 编排 job 服务，举例 slave 节点来说，主要是声明一个 job 类型的工作负载，将生成的任务从节点名以及任务生成的命名空间渲染上去，然后设置我们的压测基础镜像以及启动命令，这里我们用到了 kubernetes 的几个技巧。一个是通过 hostAliases 进行内部解析，这样可以对一些内网代理进行压测，另一个是声明申请资源CPU，以便在任务启动前提前伸缩好物理节点提供资源，还有一个是通过 configmap 挂载可执行文件，这样可以注入参数在变化的启动命令，而不需要重新构建镜像。 然后说一下我们的代码框架，主要是分为这几个模块： K8s模块，提供一些如创建销毁命名空间或 pod、查看状态、拉取日志等api功能； 基础镜像，较为简单，主要安装了一些基础通用的库，然后开通了一些内部使用的端口； 任务编排声明文件，包括了我上面说的几种节点服务； 任务核心方法类，主要是将上述的流程代码实现，提供了一些方法，这里限于篇幅就不具体展开了。 然后最后我们来看下效果： 这是我们压测系统的管理界面，现在看到的是压测集，方便集中管理。 这是创建压测场景，并基于该场景编写 python 压测脚本，并可设置我们的任务参数。 这是压测任务详情页，可以看到压测参数、状态以及节点情况和查看日志。 这是压测过程中实时生成的图表，可以基于图表情况进行分析。 ","date":"2021-04-13","objectID":"/posts/2021/04/13/building-a-distributed-pressure-testing-system-based-on-kubernetes/:0:5","tags":["tech","cloud native"],"title":"荔枝微课基于 kubernetes 搭建分布式压测系统","uri":"/posts/2021/04/13/building-a-distributed-pressure-testing-system-based-on-kubernetes/"},{"categories":["Tech"],"content":"未来改进方向 引擎类型或版本允许选择更换； 批量定时分阶段的自动压测计划； 将所有涉及资源图表关联进来，形成更为详尽的报告； 任务资源限制与使用审批； 报告分析结论存档，相关问题追踪处理结果存档； 相同条件的多次压测结果对比展示； 使用更为云原生的方式管理任务的生命周期； ","date":"2021-04-13","objectID":"/posts/2021/04/13/building-a-distributed-pressure-testing-system-based-on-kubernetes/:0:6","tags":["tech","cloud native"],"title":"荔枝微课基于 kubernetes 搭建分布式压测系统","uri":"/posts/2021/04/13/building-a-distributed-pressure-testing-system-based-on-kubernetes/"},{"categories":["Tech"],"content":"Q\u0026A环节 Q：这个压测系统对于测试人员的技能有什么要求吗？ A：需要会使用编程语言编写压测脚本，并有一定的分析思考能力，通过进一步封装的话也可以降低这部分的要求，但编程的话能力会更强更灵活，比如一些复杂条件或者像要动态使用账号的情况。 Q：我们公司的压测是每次压测之前申请一批虚拟机，压完之后销毁，这种自动化压测的方式还是能节省不少成本的。我想问一下，对于操作团队使用成本高不高？ A：我们这边的压测成本是不高的，因为压测任务，我们都是放在集群上的，也就是说我们用了多少才会去申请、才会弹出那么多。等压测任务结束后，它是自动释放的，我是把资源都销毁掉的。 Q：这个对于服务在哪个云有要求吗? A：虽然我刚才说到的集群是 TKE 的，但 kubernetes 作为一项开源的、通用的标准化技术，只要能提供该服务的云，理论上都可以。 Q：你们压测会压生产吗？大概多久压一次？脏数据怎么办？ A：我们压测会在尽量不影响用户的情况下定期进行线上压测，大概是每月一次，新项目上线前也会在测试环境压，也有专门的压测集群来压，脏数据的话也是要清的，我们有机器人用户，可以针对这些用户进行脏数据清理。 Q：我们公司已经有用几台服务器来压测，想问下为什么要用 kubernetes 集群呢？ A：一方面我们当时刚好在做集群方面的实践，另一方面呢，也考虑了集群资源管理上的优势，比如资源隔离或限制，因为有的时候测试是不太清楚自己需要多少资源的，不加限制的话有的时候会占用比较多资源，还有就是任务状态、日志的收集还有就是我前面提到的一些集群的特性。 ","date":"2021-04-13","objectID":"/posts/2021/04/13/building-a-distributed-pressure-testing-system-based-on-kubernetes/:0:7","tags":["tech","cloud native"],"title":"荔枝微课基于 kubernetes 搭建分布式压测系统","uri":"/posts/2021/04/13/building-a-distributed-pressure-testing-system-based-on-kubernetes/"},{"categories":["Tech"],"content":" 导语 本文整理自又拍云举办的微服务架构设计与实践｜Open Talk 线上公开课，荔枝微课基础架构负责人王诚强做的题为《荔枝微课基础架构的演进与实践 》 的分享。本次活动还邀请了Apache APISIX 和又拍云等企业的技术专家分享 API、Service Mesh 等相关实战经验。 近几年，云原生技术和理念得到广泛接受，众多企业开始探索云原生架构转型落地。本文将会详细讲述荔枝微课是如何做云原生下的微服务基础架构设计。 王诚强，荔枝微课基础架构负责人。主要从事基础技术研究开发、基于云原生的基础架构设计以及基础架构团队的管理建设。致力于云原生理念下，以微服务搭建中台。 ","date":"2020-09-11","objectID":"/posts/2020/09/11/the-evolution-and-practice-of-tenclass-infrastructure/:0:0","tags":["tech","cloud native"],"title":"荔枝微课基础架构的演进与实践","uri":"/posts/2020/09/11/the-evolution-and-practice-of-tenclass-infrastructure/"},{"categories":["Tech"],"content":"云原生：未来架构的演化方向 云原生（Cloud Native）是未来架构的演化方向，包含了一组应用模式，用于帮助企业快速、持续、可靠、规模化地交付业务软件，由微服务架构、DevOps 和以容器为代表的敏捷基础架构组成，其中包含很多有利于我们做更多扩展持续演进的理念。我认为云原生是一种文化、一种理念， 也是一种生态，既包括技术（微服务、敏捷基础设施 K8S），也包括管理（DevOps、持续交付）， 范围极其广泛，总得来讲是一种围绕云计算时代的架构。 虽说出现得相对比早期的 Spring Cloud 要晚一些，但也是非常先进的，像谷歌最早期贡献出来的 K8S，之后各大公司也都是在这个开源项目上不断去迭代更新，因此它的生态很完善。下图中完整的展示了云原生的整个生态，包括了很多不同的环节，比如数据库，还有消息流，网关、服务网格等等，这里就不再一一列举了，大家有兴趣可以去深入了解。附CNCF全景图： ","date":"2020-09-11","objectID":"/posts/2020/09/11/the-evolution-and-practice-of-tenclass-infrastructure/:0:1","tags":["tech","cloud native"],"title":"荔枝微课基础架构的演进与实践","uri":"/posts/2020/09/11/the-evolution-and-practice-of-tenclass-infrastructure/"},{"categories":["Tech"],"content":"云原生的演进历程 2001年虚拟机进入到了一个可商用的阶段， 2013 年 Docker 发布后会发现很多开源项目、个人开发者都开始用Docker去发布自己的应用；2015年CNCF（云原生计算基金会）成立，2018 年 Kubernetes 从 CNCF 毕业，到了 2019 年我们会发现它已是大家时常谈论的热点。云原生开始大热，因为它已经形成了一个比较成熟的体系，各大云厂商也开始把自己的云服务、容器服务等开始推向市场，这时大家也不用从零开始自建，这也告诉我们要去把握技术发展的趋势，懂得借势，而不是什么都是从零开始。 ","date":"2020-09-11","objectID":"/posts/2020/09/11/the-evolution-and-practice-of-tenclass-infrastructure/:0:2","tags":["tech","cloud native"],"title":"荔枝微课基础架构的演进与实践","uri":"/posts/2020/09/11/the-evolution-and-practice-of-tenclass-infrastructure/"},{"categories":["Tech"],"content":"荔枝微课架构的演进历程 上古时期：单体架构，业务优先 所谓的上古时期可以理解成公司的创始时期，这时优先以业务为主，如果连业务都没起来又谈何去做更多的技术发展，这个阶段可能使用单体架构更容易做到迭代。不过它的优点是业务起步快，一个人单枪匹马就可以把整个项目给建起来了，可能就那么一两个服务，它的部署维护也要简单很多，目的就是先把业务做起来。 单体架构的缺点也很明显，一个单体项目功能太多，新人就不易上手，项目越做越复杂，耦合度越来越高，会给后期新进人员带来很多难题，我们私下称之为“死伤”，不利于扩展新功能。其中最麻烦的是后面的新人要去接手并开展新功能，如果代码质量有问题，可能一个局部 BUG 就会影响到整体。而且有很多已经完成的功能，会重复使用到新的业务中，比如支付、账号等这些同样的功能，难道又要重新做一遍吗？ 不过上古时期的整体架构也不一定只有一个服务器、一个服务，也是有一些伸缩性的。上图中的Users、Threads、Posts 构成了整个单体结构的应用，它是可复制的，比如在负载均衡下面挂多个。另外它是无状态的，所谓无状态是指不会因为多一台服务伸缩出来而导致服务不可用，其中需要特别注意的是一些需要设置白名单的，比如 IP 白名单，多一台机器，可能 IP 就对不上了，会导致其他的环节报错。不过这可以通过一些软件设计的方法，比如代理、生产消费这种模式去处理。 初期：初步微服务，解耦化 初期阶段单体结构会变得越来越复杂，维护起来也会越来越难。想象一下，一个系统里面可能有几十甚至上百个不同的模块，不同的文件夹，一个新人看完这些代码都需要花很多的时间，又谈何了解整体并做维护呢？甚至整个要跑起来所要了解的知识也很多。因此后面就需要会做解耦化，也就是我们所说的初步微服务化。不过初期还是由业务来推动的，这个时候的目标还是拓展不同的项目，解耦的话也不会一步就到容器化。该阶段需要先对服务做松耦合，方便新人进来后去维护代码，另外就是做很多像监控这类兜底的能力。 说到服务做松耦合（解耦），因为早期没有很好的统筹，很多应用是解耦了，但它的技术栈多而杂，甚至连部署方式也都不一样，如果是原来维护项目的开发人员走了，由你来接手，它的语言、框架、部署方式都不同，维护工作会很难进行。拆分后也会面临到服务关系问题，服务少的时候还能明确服务之间的调用关系，当服务多了后，调用关系就会比较乱，特别是为了方便调用，快速上线将配置跟代码混合一起的情况，这样拆分后反而会带来更多麻烦。因此上古时期以业务为主，需要衡量一下是否拆分，业务有没有这个需求，不能因为做拆分而影响业务，另一个是如果人员不够也不适合去做拆分，维护起来会更麻烦。 整体式架构拆分如上图所示，这里写到是 Container Ports，与以前相比更理想化了一些，需要先进行容器化，拆分之后将 Users 服务、Threads 服务、Posts 服务分别对应不同的 API 入口，分别去扩展会更利于去维护。比如负责 Posts 开发的，就只需专注于这一块。 领域驱动设计与微服务 拆分中有一个词叫领域驱动设计（Domain-Driven Design，简称 DDD），是一种由域模型来驱动系统设计的思想，最早前的还是通过数据库等数据源来驱动系统设计 （Model-Driven Design，简称 MDD）。领域驱动则会划分业务和功能，比如说支付、订单或者是用户等，拆分后的可复用性就更强了，相互调用就可以。领域模型是对业务模型的抽象，领域驱动设计相对比较复杂，有兴趣的可以去深入了解，总的来说规划设计不是一成不变的，按自己最适合的来就好了。 拆分后也会面临一些问题，因为服务变多了，部署、管理、资源规划会特别麻烦，期望每一个微服务有自己的专用数据库，前面说到了要衡量是否拆分，规模很小的话做这个是得不偿失的，应该先把量做起来，比如单表过亿、超大量了，对数据库做组成、只读、读写分离、分表都没有用的时候再去考虑分库。而且拆分之后使用了专用数据库，它们之间的调用会是个麻烦，特别是分布式事务，下面会再详细讲解。 中期：深水期改革，实现集群化 中期是集群化的过程，也可以说是容器化。我个人认为在当时的时间节点上，顺序可能是反了，应该是容器化做得越早越好，这样解耦的时候会减少很多不必要的麻烦，当然这个也跟历史时间的趋势有关系，可能之前没有兴趣，大家觉得这个技术不成熟，不敢用，因此还是按老的方式解耦。但如果是现在还未开展这些工作，需要之后再去做的，是可以把容器化提前一些的。 对我们而言，中期要做的是要把初步微服务化过程中存在的一些问题纠正过来，需要统一配置中心，分离代码和配置；统一开发测试流程，统一持续集成持续部署方式，做容器化、集群化改造，提供更为全面的监控告警体系。虽然在初期微服务化时也做了一些监控方面的工作，但既然进到了云原生，相比在单台的 vm 机上做监控，形式会不太一样，但是理念都是相通的，需要升级到更适合集群化上的监控告警能力。 改革都是向云原生靠拢的，具体措施在于初步微服务化后，通过引入K8S以解决服务管理、资源管理问题，并进入云原生生态，这样很多东西都能用起来，避免重复建设；引入 DevOps 解决自动化流程问题，包括自动测试、代码质量评估、构建、部署等；引入Istio解决网关和服务治理问题。 当然上述这些改革可以根据自己的情况去适配，不过也会面临一些问题。我们不仅要着眼于软件架构，还需要有更多基础架构的视野，有些问题需要基础架构的能力去解决，又或是软件架构能解决但实现起来特别复杂的，这时交给基础架构去做会简单很多。另外，设计如此多的改造、变更开发设施流程需要更多的跨部门沟通与资源，造成成本增加；改造后也会带来一些风险，需要检测评估出台兜底方案。此外，改造中要用到很多新的东西，需要我们持续不断的学习去汲取知识才能一直往前走。 云原生应用与传统应用的区别 云原生在一个更好的基础平台与设施上提供了更多的应用。因为做了容器化就不需要指定操作系统，K8S 的资源调度更有弹性，之前需要通过代码来协调实现伸缩策略，比较麻烦，借助DevOps 会容易达成协作，因为它整个流程都是自动的，能够敏捷开发。还有微服是都是各自独立的，具有高内聚、低耦合的原则，具有自动化运维、快速恢复的特点，自愈能力强。当集群宕掉了，它会自动拉起，比如之前深夜业务故障可能需要定位到哪个服务宕掉了，再重新启动起来，现在就不用这么麻烦，它会自动重新挂起，用户甚至都不会感知。 如上图所示，原有架构是没有集群化的，比较乱；新架构做了集群化，甚至是做了网络隔离。说起网络隔离，有些公司可能觉得没必要，当测试环境跟生产环境在同一个网络，会引入一些不确定的因素，如果是上面的应用出现漏洞，有可能会被挖矿，甚至影响到生产环境，而网络隔离能有效的防止这种情况。新架构的优势在于通过集群化的过程可以实现有序管理、安全隔离，功能也更强大，像上面说到的自愈、资源编排等，生态也更加好了。当然我们不仅是关注外部服务，其他云原生上的应用可以直接通过 Helm 之类的去安装。 再提到 DevOps，这是通过不同的环节去建设的，从编码到上线监控做服务治理，都是按下图的流程走完，到后面的能力也越来越强。在编码开发环节，关注的是代码仓库、代码质量，像代码质量监测，是之后一步步去往上加的。测试也是一样，最早是自己做一个功能去测试，后面加了很多自动化测试的手段，比如压测，可以保证代码上线的质量。 大家也许会觉得上线之前加那么多环节，那迭代速度不就变慢了吗？其实这是一个错误的认知，真正会变慢的是代码质量不行，带着 BUG 上线，发现后回滚甚至可能会直接带来损失。这要是放在在以前的工厂，这种叫返工、召回，会更加影响效率，只有成功的发布才算是有效率的迭代。 构建环节最早是自己把文件、代码、环境依赖等打包好，传到服务器，需要依赖服务器的自启动手段去维护应用。做了容器化后，通过容器镜像，打包成镜像，它的环境会处于一个隔离的状态，不易受到影响，再利用 DevOps 的 pipline+K8S 去发布。环境做了更明确切分，发布形式从最早的灰度到可以滚动升级。 监控方面，最早只有日志采集和 statsd 监控，上了集群后就有 prometheus 去提供更多的监控信息。告警环节，从最早的邮件到企业微信，现在能更直接及时地收到事件信息，sentry 把报错收集过来，就可以及时定位到问题。分析也是这样，如果对流程不熟悉，出问题后查找定位可能要花很多时间来分析，而现在做到了一键分析、慢查询分析、RDB 分析，甚至监控曲线更智能的分析，当然现在云厂商出售的服务器也会提供这些能力。 上线治理中，最早是当发现某个服务有异常，除了在 LB 负载均衡调权重，没有其他更好的办法，只能通过代码发版去做降级。有服务治理之后，就可以在这一层做像熔断之类的处理，例如有 K8S 之后，资源的调度、伸缩都更自动化了，再引入 Istio 、链路追踪、访问控制等可以得到更好的加强。 分布式事务 分布式事务是相对本地事务而言的，而数据库本地事务有A（原子性）、C（一致性）、I(隔离性)、D（持久性）等四大特性。通俗来讲就是一次性把所有事情打包做完，它是一个分布式的。说到分布式肯定要提到布鲁尔定理（CPA 定理），具有 C (一致性)、A ( 可用性)、P (分区容错性)的特性。 理解了概念之后才能提出更好的解决手段，因为 CPA 中理论上没有网络延迟，而实际现实里是有的，所以在 CPA 定理上加一个 BASE，即 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)，可以理解是对 CAP 中 AP 的一","date":"2020-09-11","objectID":"/posts/2020/09/11/the-evolution-and-practice-of-tenclass-infrastructure/:0:3","tags":["tech","cloud native"],"title":"荔枝微课基础架构的演进与实践","uri":"/posts/2020/09/11/the-evolution-and-practice-of-tenclass-infrastructure/"},{"categories":["Tech"],"content":"如何确定架构方向 架构的方向始终是围绕需不需要、方不方便、稳不稳定、适不适合等展开的。单体架构也不一定不适合，主要看业务、成本、效率是否需要，如需要则是可以保留的，或是当达到了一定规模有需求时再去考虑。在考虑如何规划架构时，可以从研发效率、扩展性等方面考虑是否更方便，当然最关键的是保持稳定性。 微服务的五大原则 不要构建微服务，即不要为了微服务而微服务，视实际情况而定 不要在没有 DevOps 或者云服务的情况下进行微服务，要顺势而为，借力打力 不要通过使它们变得太小来制造太多的微服务 不要把将微服务转变为 SOA 不要尝试成为 Netflix，不需要什么都从头开始 架构的评价方法 性能测试，比如网络耗时 压力测试，检测架构漏洞和需改进的 定期演练，定期检测 团队、用户是否满意，要根据反馈不断的改进 从一年前的事故频发到中间一段时间的误报，这个过程我们也做了很多改进，因为毛刺会直接影响我们的判断。还有些是第三方平台事故，针对第三方的问题首先是要沟通迫使对方去改进，再者自己也做好一些灾备方案，比如选择更多的合作商。今年我们步入平稳增长期，基本上就没有毛刺了。 以上是王诚强在又拍云 Open Talk 公开课上的主要内容分享，视频观看、PPT 下载请点击这里。 ","date":"2020-09-11","objectID":"/posts/2020/09/11/the-evolution-and-practice-of-tenclass-infrastructure/:0:4","tags":["tech","cloud native"],"title":"荔枝微课基础架构的演进与实践","uri":"/posts/2020/09/11/the-evolution-and-practice-of-tenclass-infrastructure/"}]