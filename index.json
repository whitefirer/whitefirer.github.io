[{"categories":["Tech"],"content":"背景 如融合、扩展Service Mesh文中所述，为了让第三方服务发现的服务能够接入到Istio服务网格当中，我设计开放一个名为Polaris2Istio的组件。 ","date":"2022-08-30","objectID":"/posts/2022/08/30/polaris2istio/:0:1","tags":["tech","cloud native","service mesh","istio"],"title":"Polaris2Istio的实现和说明","uri":"/posts/2022/08/30/polaris2istio/"},{"categories":["Tech"],"content":"设计图 ","date":"2022-08-30","objectID":"/posts/2022/08/30/polaris2istio/:0:2","tags":["tech","cloud native","service mesh","istio"],"title":"Polaris2Istio的实现和说明","uri":"/posts/2022/08/30/polaris2istio/"},{"categories":["Tech"],"content":"时序图 ","date":"2022-08-30","objectID":"/posts/2022/08/30/polaris2istio/:0:3","tags":["tech","cloud native","service mesh","istio"],"title":"Polaris2Istio的实现和说明","uri":"/posts/2022/08/30/polaris2istio/"},{"categories":["Tech"],"content":"使用方式 编译 make build 运行 polaris2istio --polarisAddress \u003cpolarishost:port\u003e 配置 模式 1. 基于ServiceEntry的管理标签筛选同步Polaris实例: apiVersion: networking.istio.io/v1alpha3 kind: ServiceEntry metadata: name: \u003cpolaris-name-for-k8s\u003e namespace: polaris annotations: aeraki.net/polarisNamespace: Test aeraki.net/polarisService: test-service aeraki.net/external: \"false\" labels: manager: aeraki registry: polaris spec: hosts: - dev.\u003cpolaris-name-for-k8s\u003e.polaris resolution: NONE # or STATIC 详细说明请参考：https://github.com/aeraki-mesh/polaris2istio ","date":"2022-08-30","objectID":"/posts/2022/08/30/polaris2istio/:0:4","tags":["tech","cloud native","service mesh","istio"],"title":"Polaris2Istio的实现和说明","uri":"/posts/2022/08/30/polaris2istio/"},{"categories":["Tech"],"content":"心得技巧 保持分配好的VIP // polaris2istio/pkg/serviceregistry/polaris/watcher/provider.go func (w *ProviderWatcher) syncPolarisServices2Istio(polarisInfo *model.PolarisInfo) { klog.Infof(\"[syncPolarisServices2Istio] polarisInfo: %v\", polarisInfo) rsp, err := w.polarisclient.GetPolarisAllInstances(polarisInfo.PolarisNamespace, polarisInfo.PolarisService) if err != nil { klog.Errorf(\"[syncPolarisServices2Istio] query polaris services' instances failed, err: %v\", err.Error()) return } newServiceEntry, newAnnotations := model.ConvertServiceEntry(rsp, polarisInfo) if newServiceEntry == nil { klog.Errorf(\"convertServiceEntry failed?\") return } oldServiceEntry, err := w.ic.NetworkingV1alpha3().ServiceEntries(w.configRootNS).Get(context.TODO(), model.CovertServiceName(polarisInfo.PolarisNamespace, polarisInfo.PolarisService), v1.GetOptions{}) if err != nil { klog.Infof(\"[syncPolarisServices2Istio] get old service entries failed, error: %v\", err) return } newServiceEntry.Addresses = append(newServiceEntry.Addresses, oldServiceEntry.Spec.GetAddresses()...) if revision, exists := oldServiceEntry.GetAnnotations()[\"aeraki.net/revision\"]; !exists || newAnnotations[\"aeraki.net/revision\"] != revision { klog.Infof(\"[syncPolarisServices2Istio] update serviceentry: %v\", newServiceEntry) _, err = w.ic.NetworkingV1alpha3().ServiceEntries(oldServiceEntry.Namespace).Update(context.TODO(), w.toServiceEntryCRD(model.CovertServiceName(polarisInfo.PolarisNamespace, polarisInfo.PolarisService), newServiceEntry, oldServiceEntry, newAnnotations), v1.UpdateOptions{FieldManager: aerakiFieldManager}) if err != nil { klog.Errorf(\"failed to update ServiceEntry: %s\", err.Error()) } } else { log.Infof(\"[syncPolarisServices2Istio] serviceentry unchanged: %v\", oldServiceEntry.GetName()) } } 代码 ","date":"2022-08-30","objectID":"/posts/2022/08/30/polaris2istio/:0:5","tags":["tech","cloud native","service mesh","istio"],"title":"Polaris2Istio的实现和说明","uri":"/posts/2022/08/30/polaris2istio/"},{"categories":["Tech"],"content":"注意事项 只对polaris命名空间中的ServiceEntrys同步； 在集群中运行时需要为其配置权限策略； 开源版本的polaris sdk是需要手动设置polaris地址的，与内部版不同； ","date":"2022-08-30","objectID":"/posts/2022/08/30/polaris2istio/:0:6","tags":["tech","cloud native","service mesh","istio"],"title":"Polaris2Istio的实现和说明","uri":"/posts/2022/08/30/polaris2istio/"},{"categories":["Tech"],"content":" 导语 没有最完美的架构，只有最合适的架构。 ","date":"2022-08-29","objectID":"/posts/2022/08/29/extension-and-expansion-of-service-mesh/:0:0","tags":["tech","cloud native","service mesh"],"title":"融合、扩展Service Mesh","uri":"/posts/2022/08/29/extension-and-expansion-of-service-mesh/"},{"categories":["Tech"],"content":"背景 很多时候服务网格在业务难以落地，往往是因为有历史包袱或者特殊需求，反而没有新设计的项目接入服务网格容易，而原因多是以下几点： 难点 私有协议：不能识别私有协议，无法对私有协议进行流量管理（如路由等）； 不能很好地平滑过渡掉原有的北极星或者Consul服务发现； 第三方服务发现：比如北极星服务发现得到的IP是实例IP，我们这边要想办法让流量走到ServiceIP上去，通过Virtual Service IP加端口来确定服务和协议，才能利用到边车来管理流量和解析自定义协议； ","date":"2022-08-29","objectID":"/posts/2022/08/29/extension-and-expansion-of-service-mesh/:0:1","tags":["tech","cloud native","service mesh"],"title":"融合、扩展Service Mesh","uri":"/posts/2022/08/29/extension-and-expansion-of-service-mesh/"},{"categories":["Tech"],"content":"解决方案 私有协议 私有协议服务网格的解决方案大概有以下两种 协议转换 协议扩展 协议转换 协议转换顾名思议就是将协议转换成网格内支持的方案。 一种是在client多实现个协议转换层，但开发以及部署更新麻烦，但如gRPC-gateway也是种实现方式，只不过gRPC在Istio本身就支持； 一种是在边车、adapter或者边缘网关服务去做转换，但一样有上面的问题； 且有可能目前网格内的协议并不合适业务场景，比如性能下降等问题； 协议扩展 这里的协议扩展是指通过Service Mesh来扩展支持私有协议及任意的尚未支持的协议。 自研 自研肯定是能实现的，但对技术要求较高，需要要对数据面修改的技术能力，像Envoy是用C++实现的，另外控制面也要做一定修改。 Aeraki Aeraki Mesh可以帮助你在服务网格中管理任何七层协议。目前已经支持了 Dubbo、Thrit、Redis、Kafka、ZooKeeper 等开源协议。你还可以使用 Aeraki Mesh 提供的 MetaProtocol 协议扩展框架来管理私有协议的七层流量。 /** * Codec for Awesomerpc protocol. */ class AwesomerpcCodec : public MetaProtocolProxy::Codec, public Logger::Loggable\u003cLogger::Id::misc\u003e { public: AwesomerpcCodec() {}; ~AwesomerpcCodec() override = default; //协议解码，需要解析 buffer 并填充 Metadata， Metadata 将被用于 MetaProtocol Proxy 的 filter，例如限流，路由的匹配条件 MetaProtocolProxy::DecodeStatus decode(Buffer::Instance\u0026 buffer, MetaProtocolProxy::Metadata\u0026 metadata) override; //协议编码，可以根据 Mutation 对请求或者响应数据包进行修改，例如增加、删除或者修改 header，修改后需要回写到 buffer 中 void encode(const MetaProtocolProxy::Metadata\u0026 metadata, const MetaProtocolProxy::Mutation\u0026 mutation, Buffer::Instance\u0026 buffer) override; //错误编码，用于框架向客户端返回错误信息，例如未找到路由或者连接创建失败等，编码的数据需要写入到 buffer 中 void onError(const MetaProtocolProxy::Metadata\u0026 metadata, const MetaProtocolProxy::Error\u0026 error, Buffer::Instance\u0026 buffer) override; ... 实现编解码接口较简单，仅需实现 decode，encode 和 onError 三个方法即可。 而其它服务治理能力都已经通过MetaPortocol这个EnvoyFilter，以插件的形式统一实现了支持。 而在Istio中声明使用它也较简单，仅需创建一个 Aeraki 的 ApplicationProtocol CRD资源： apiVersion: metaprotocol.aeraki.io/v1alpha1 kind: ApplicationProtocol metadata: name: my-protocol namespace: istio-system spec: protocol: my-protocol codec: aeraki.meta_protocol.codec.my_protocol 第三方服务发现 几种融合网格服务发现名字的方案对比： 方案名 优点 缺点 基于服务发现代理 完全不需要修改业务代码 需要开发代理服务 基于边车 更符合后面网格建设的规范 能处理自定义协议 需要修改业务请求Client 在边车中进行服务发现较重 基于配置 原理较为简单 需要修改业务请求Client 不够灵活，不够通用 基于DNS 原理较为简单，易维护 需要修改业务请求Client DNS+边车 原理较为简单，易维护 能处理自定义协议 需要修改业务请求Client 服务发现改成非k8s service 可以照顾原有VM上的服务 需要自研控制面，数据面也要进行一些修改 我个人比较喜欢的是代理、DNS和用Consul替代的这三种方案，其中最符合istio原有流程是DNS这种，方案过多，就不一一详细说明了，这里主要提DNS模式下，通过X2Istio注册ServiceEntry的方式。 X2Istio (Polaris2Istio) Istio可用特性 ServiceEntry自动分配VIP； Service ExternalName提供DNS CNAME记录； 利用上述特性可制定以下方案： 说明 走方式4调用将上报给Polaris组件以供他自动建立新的ServiceEntry，这样就回到了方式3，后面就不用再进行L5发现而是直接DNS解析走ServiceIP了； 走方式3调用的服务如果后面迁移到了集群内，那么将externalName改成集群内的Service，后面变成方式2，这样就可以具备完整的网格能力； 当主调都改成直接使用ServiceName时，将都走方式1，有其它几种调用方式的存在，将大大降低业务改造的工作量。 图中的Polaris2Istio就相当于本图中的X2Istio。 Polaris2Istio: https://github.com/aeraki-mesh/polaris2istio SentryEntry自动分配IP并解析 DNS 代理还支持为没有明确定义的 ServiceEntry 自动分配地址。这是通过 ISTIO_META_DNS_AUTO_ALLOCATE 选项配置的。 启用此特性后，DNS 响应将为每个 ServiceEntry 自动分配一个不同的独立地址。然后代理能匹配请求与 IP 地址，并将请求转发到相应的 ServiceEntry。 参考：https://istio.io/latest/zh/docs/ops/configuration/traffic-management/dns-proxy/ DNS解析 DNS是k8s内部就在使用的名字解析服务（目前集群中使用的是CoreDNS），我们只要解决名字转义后的域名能够一样解析到ServiceIP就能解决服务发现的问题，这里可以利用Service本身就有EnternalName来CNAME解析解决。 参考：https://github.com/kubernetes/kubernetes/issues/39792 externalname 参考：https://kubernetes.io/docs/concepts/services-networking/service/#externalname ServiceEntry 可按如下配置： apiVersion: networking.istio.io/v1alpha3 kind: ServiceEntry metadata: name: \u003cpolaris-name-for-k8s\u003e namespace: polaris annotations: aeraki.net/polarisNamespace: Test aeraki.net/polarisService: test-service aeraki.net/external: \"false\" labels: manager: aeraki registry: polaris spec: hosts: - dev.\u003cpolaris-name-for-k8s\u003e.polaris resolution: NONE # or STATIC 参考： https://github.com/aeraki-mesh/polaris2istio 请注意我们集群当中使用的是CoreDNS，它要求externalName的格式必须是符合FQDN的，即最全的形式。 对于已经在集群当中的Service，只需要创建有原服务发现名字和service映射关系的externalName类型的Service就行； 对于不在集群当中的L5服务，则需要先创建ServiceEntry按入网格，并通过Polaris2Istio来维护实例变更； 由于各项目不一样，源码中没有根据管理的Service来匹配，而是直接创建相应的ServiceEntry即可。 关于Polaris的具体实现，下篇文章再讲。 ","date":"2022-08-29","objectID":"/posts/2022/08/29/extension-and-expansion-of-service-mesh/:0:2","tags":["tech","cloud native","service mesh"],"title":"融合、扩展Service Mesh","uri":"/posts/2022/08/29/extension-and-expansion-of-service-mesh/"},{"categories":["Tech"],"content":"总结 现实情况不总是理想模型，我们要根据实际情况进行调整，没有最完美的架构，只有最合适的架构。 ","date":"2022-08-29","objectID":"/posts/2022/08/29/extension-and-expansion-of-service-mesh/:0:3","tags":["tech","cloud native","service mesh"],"title":"融合、扩展Service Mesh","uri":"/posts/2022/08/29/extension-and-expansion-of-service-mesh/"},{"categories":["Tech","Workspace"],"content":"工欲善其事，必先利其器","date":"2022-08-29","objectID":"/posts/2022/08/29/efficient-command-line-tools/","tags":["tech","command-line-tools"],"title":"高效终端命令行工具","uri":"/posts/2022/08/29/efficient-command-line-tools/"},{"categories":["Tech","Workspace"],"content":" 导语 工欲善其事，必先利其器。 作为技术人员，一个高效的工作环境尤为重要。下面分享下我的终端命令行下的环境和工具配置。 zsh\u0026oh-my-zsh 安装 参考：https://ohmyz.sh/ 插件 语法高亮（zsh-syntax-highlighting） git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 自动补全（zsh-autosuggestions） git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 集群环境显示（zsh-kubectl-prompt) 可参考https://github.com/whitefirer/workspace/blob/main/.zshrc进行配置： # .zshrc function right_prompt() { local color=\"blue\" if [[ \"$ZSH_KUBECTL_NAMESPACE\" =~ \"system\" ]]; then color=\"yellow\" fi if [[ \"$ZSH_KUBECTL_CONTEXT\" =~ \"desktop\" || \"$ZSH_KUBECTL_CONTEXT\" =~ \"dev\" ]]; then color=\"green\" fi if [[ \"$ZSH_KUBECTL_CONTEXT\" =~ \"prod\" ]]; then color=\"red\" fi echo \"%{$terminfo[bold]$fg[$color]%}\\u2638($ZSH_KUBECTL_PROMPT)%{$reset_color%}\" } RPROMPT='$(right_prompt)' 成功后会显示如下： 其中cni-test为自己在kubeconfig中给context取的名字，可自行修改。 里面的ctx和ns均为krew插件。 kubectl备忘录 kubectl安装\u0026操作 其它可参考：https://kubernetes.io/docs/tasks/tools/#install-kubectl 更多相关备忘：https://kubernetes.io/zh/docs/reference/kubectl/cheatsheet/ kubectl插件（krew） 参考：https://krew.sigs.k8s.io/ kubectl高亮（kubecolor） 可以参考https://github.com/hidetatz/kubecolor readme里的做法，alias成k或者kubectl。 其它 终端复用（tmux） GitHub：https://github.com/tmux/tmux 参考：https://www.ruanyifeng.com/blog/2019/10/tmux.html 高级cat（bat) 参考：https://github.com/sharkdp/bat/blob/master/doc/README-zh.md 高级模糊查找（fzf） 参考：https://github.com/junegunn/fzf#preview-window 右侧的预览是结合了前面的bat命令。 高级ls（exa） 安装 参考：https://github.com/ogham/exa 高级top（htop） 安装 brew install htop json高亮（jq） brew install jq json高亮及折叠（fx） 安装 brew install fx 官网 https://github.com/antonmedv/fx yaml高亮（yh） 当然有使用kubecolor的话，kubectl也用不上yh，但是其它命令场景还是可以用的。 安装 brew install yh ","date":"2022-08-29","objectID":"/posts/2022/08/29/efficient-command-line-tools/:0:0","tags":["tech","command-line-tools"],"title":"高效终端命令行工具","uri":"/posts/2022/08/29/efficient-command-line-tools/"},{"categories":["Hugo"],"content":"Asciinema-Player是一款著名的的终端录制播放器，可用于播放asciinema录制的播放文件，经常被用来进行终端操作演示。这里也将其引入到了当前Hugo博客中使用，下面我将讲讲引入的过程。 ","date":"2022-08-28","objectID":"/posts/2022/08/28/hugo-asciinema-player/:0:0","tags":["hugo","tech","asciinema"],"title":"如何在Hugo博客中使用终端播放器Asciinema-Player","uri":"/posts/2022/08/28/hugo-asciinema-player/"},{"categories":["Hugo"],"content":"1.效果展示 Talk is cheap, show the result ~ 这里直接借用官方demo进行展示。 ","date":"2022-08-28","objectID":"/posts/2022/08/28/hugo-asciinema-player/:0:1","tags":["hugo","tech","asciinema"],"title":"如何在Hugo博客中使用终端播放器Asciinema-Player","uri":"/posts/2022/08/28/hugo-asciinema-player/"},{"categories":["Hugo"],"content":"2.需求分析 为什么需要在Hugo里面使用终端播放器Asciinema-Player呢？ 作为技术人员，在写博客时总是需要进行一些终端操作演示，而演示方式无非以下几种： 方式 优点 缺点 视频 能配音配特效 网站流量消耗大，不能复制文本 动图 文件相对小些 不能控制进度，不能复制文本 代码 占用流量小，能复制 不能控制进度，也不太好展示效果 而终端录制播放器Asciinema-Player则兼容体积小、能控制、能复制于一体并能完美复现终端操作场景，非常适合用于在博客中进行一些终端操作演示。 ","date":"2022-08-28","objectID":"/posts/2022/08/28/hugo-asciinema-player/:0:2","tags":["hugo","tech","asciinema"],"title":"如何在Hugo博客中使用终端播放器Asciinema-Player","uri":"/posts/2022/08/28/hugo-asciinema-player/"},{"categories":["Hugo"],"content":"3.解决方案 首先，在网上找下前人在Hugo博客里扩展嵌入asciinema-player的方法，比如 Embedding asciinema cast in your Hugo site。 shortcode 可以找到里面asciinema-player的shortcode代码如下： \u003cp\u003e \u003casciinema-player src=\"/casts/{{ with .Get \"key\" }}{{ . }}{{ end }}.cast\" cols=\"{{ if .Get \"cols\" }}{{ .Get \"cols\" }}{{ else }}640{{ end }}\" rows=\"{{ if .Get \"rows\" }}{{ .Get \"rows\" }}{{ else }}10{{ end }}\" {{ if .Get \"autoplay\" }}autoplay=\"{{ .Get \"autoplay\" }}\"{{ end }} {{ if .Get \"preload\" }}preload=\"{{ .Get \"preload\" }}\"{{ end }} {{ if .Get \"loop\" }}loop=\"{{ .Get \"loop\" }}\"{{ end }} start-at=\"{{ if .Get \"start-at\" }}{{ .Get \"start-at\" }}{{ else }}0{{ end }}\" speed=\"{{ if .Get \"speed\" }}{{ .Get \"speed\" }}{{ else }}1{{ end }}\" {{ if .Get \"idle-time-limit\" }}idle-time-limit=\"{{ .Get \"idle-time-limit\" }}\"{{ end }} {{ if .Get \"poster\" }}poster=\"{{ .Get \"poster\" }}\"{{ end }} {{ if .Get \"font-size\" }}font-size=\"{{ .Get \"font-size\" }}\"{{ end }} {{ if .Get \"theme\" }}theme=\"{{ .Get \"theme\" }}\"{{ end }} {{ if .Get \"title\" }}title=\"{{ .Get \"title\" }}\"{{ end }} {{ if .Get \"author\" }}author=\"{{ .Get \"author\" }}\"{{ end }} {{ if .Get \"author-url\" }}author-url=\"{{ .Get \"author-url\" }}\"{{ end }} {{ if .Get \"author-img-url\" }}author-img-url=\"{{ .Get \"author-img-url\" }}\"{{ end }} \u003e\u003c/asciinema-player\u003e \u003c/p\u003e 细细口味了下这段代码，结合自己需求进行了修改： Talk is cheap, show me the code ~ # themes/iLoveIt/layouts/shortcodes/asciinema.html \u003cp\u003e \u003casciinema-player {{- with .Get \"src\" }} src=\"{{ . }}\" {{ end -}} {{- with .Get \"key\" }} src=\"/casts/{{ . }}.cast\"{{ end -}} cols=\"{{ if .Get \"cols\" }}{{ .Get \"cols\" }}{{ else }}640{{ end }}\" rows=\"{{ if .Get \"rows\" }}{{ .Get \"rows\" }}{{ else }}10{{ end }}\" {{- with .Get \"autoplay\" }}autoplay=\"{{ . }}\"{{ end -}} {{- with .Get \"preload\" }}preload=\"{{ . }}\"{{ end -}} {{- with .Get \"loop\" }}loop=\"{{ . }}\"{{ end -}} start-at=\"{{ if .Get \"start-at\" }}{{ .Get \"start-at\" }}{{ else }}0{{ end }}\" speed=\"{{ if .Get \"speed\" }}{{ .Get \"speed\" }}{{ else }}1{{ end }}\" {{- with .Get \"idle-time-limit\" }}idle-time-limit=\"{{ . }}\"{{ end -}} {{- with .Get \"poster\" }} poster=\"{{ . | safeURL }}\"{{ end -}} {{- with .Get \"font-size\" }}font-size=\"{{ . }}\"{{ end -}} {{- with .Get \"theme\" }}theme=\"{{ . }}\"{{ end -}} {{- with .Get \"title\" }}title=\"{{ . }}\"{{ end -}} {{- with .Get \"author\" }}author=\"{{ . }}\"{{ end -}} {{- with .Get \"author-url\" }}author-url=\"{{ . }}\"{{ end }} {{- with .Get \"author-img-url\" }}author-img-url=\"{{ . }}\"{{ end -}} fit=\"{{ if .Get \"fit\" }}{{ .Get \"fit\" }}{{ else }}width{{ end }}\" \u003e\u003c/asciinema-player\u003e {{- .Page.Scratch.SetInMap \"this\" \"asciinema\" true -}} \u003c/p\u003e 注意看高亮部分，主要修改了以下几点： 修改点 if .Get 形式代码过于累赘，这里把不需要取默认值的语句统统改成了with .Get形式； 只有固定的key方法从本站获取.cast录制文件，这里扩展了src以便从站外获取录制文件地址； poster这里会得到一个奇怪的数据#ZgotmplZ，它是一个安全防护的默认数据，见官方说明，会导致设置指定时间封面无效，解决起来也简单，加上| safeURL管道方法就可解决； js、css 参考方案里动态引入js和css，用到的该播放器的文章里需设置asciinema为true： {{ if .Params.asciinema }} \u003cscript src=\"{{ .Site.BaseURL }}js/asciinema-player.js\"\u003e\u003c/script\u003e {{ end }} --- title: Kubernetes Backup - ARK description: Kubernetes backup process using ark asciinema: true tags: - kubernetes - backup --- 可以看到上面是通过在文章里加asciinema参数实现的js、css资源动态加载，其实可以参考其它如mermaid的接入方式，直接在渲染时置标记就好： # themes/iLoveIt/layouts/partials/assets.html {{- /* asciinema */ -}} {{- if (.Scratch.Get \"this\").asciinema | or $params.draft -}} {{- $source := \"lib/asciinema/asciinema-player.min.css\" -}} {{- dict \"Source\" $source \"Fingerprint\" $fingerprint | dict \"Scratch\" .Scratch \"Data\" | partial \"scratch/style.html\" -}} {{- $source := \"lib/asciinema/asciinema-player.min.js\" -}} {{- dict \"Source\" $source \"Fingerprint\" $fingerprint | dict \"Scratch\" .Scratch \"Data\" | partial \"scratch/script.html\" -}} {{- end -}} 其中$params.draft是为了开发模式下也能设置草稿参数进行预览: # themes/iLoveIt/assets/data/cdn/jsdelivr.yml gitalkJS: gitalk@1.7.2/dist/gitalk.min.js # valine@1.5.0 https://valine.js.org/ valineJS: valine@1.5.0/dist/Valine.min.js asciinemaJS: asciinema-player@3.0.1/dist/index.min.js # cookieconsent@3.1.1 https://github.com/osano/cookieconsent cookieconsentCSS: cookieconsent@3.1.1/build/cookiecons","date":"2022-08-28","objectID":"/posts/2022/08/28/hugo-asciinema-player/:0:3","tags":["hugo","tech","asciinema"],"title":"如何在Hugo博客中使用终端播放器Asciinema-Player","uri":"/posts/2022/08/28/hugo-asciinema-player/"},{"categories":["Hugo"],"content":"4.使用方法 asciinema-player asciinema-player即播放器，在博客中使用只需简单在文章中加入以下代码： 其中，cols、rows分别为行列，preload则是要不要预加载，poster则是封面，有data模式也有npt模式，npt即按时间截取封面，上面的就是截取55秒时的终端作为封面。 另外还有speed：播放速度，autoplay：自动播放等参数，具体可参考asciinema-player设置 呈现效果如下（借用了helix-editor的演示，文件大些可能加载慢些）： 点击播放按钮播放，可拖动进度条或者使用方向键控制播放进度。 asciinema 上述终端播放所使用的cast文件，都是使用asciinema在终端录制的。 安装 brew install asciinema 使用 ➜ ~ asciinema --help usage: asciinema [-h] [--version] {rec,play,cat,upload,auth} ... Record and share your terminal sessions, the right way. positional arguments: {rec,play,cat,upload,auth} rec Record terminal session play Replay terminal session cat Print full output of terminal session upload Upload locally saved terminal session to asciinema.org auth Manage recordings on asciinema.org account options: -h, --help show this help message and exit --version show program's version number and exit example usage: Record terminal and upload it to asciinema.org: asciinema rec Record terminal to local file: asciinema rec demo.cast Record terminal and upload it to asciinema.org, specifying title: asciinema rec -t \"My git tutorial\" Record terminal to local file, limiting idle time to max 2.5 sec: asciinema rec -i 2.5 demo.cast Replay terminal recording from local file: asciinema play demo.cast Replay terminal recording hosted on asciinema.org: asciinema play https://asciinema.org/a/difqlgx86ym6emrmd8u62yqu8 Print full output of recorded session: asciinema cat demo.cast For help on a specific command run: asciinema \u003ccommand\u003e -h 另外如果想将其转化为gif动图，也可以使用asciicast2gif。 ","date":"2022-08-28","objectID":"/posts/2022/08/28/hugo-asciinema-player/:0:4","tags":["hugo","tech","asciinema"],"title":"如何在Hugo博客中使用终端播放器Asciinema-Player","uri":"/posts/2022/08/28/hugo-asciinema-player/"},{"categories":["Hugo"],"content":"5.总结 通过以上实践，虽然过程有些曲折，但最终还是顺利地将asciinema-player终端播放器引入到了hugo中使用，后续发布的博客也将经常见到其身影。 ","date":"2022-08-28","objectID":"/posts/2022/08/28/hugo-asciinema-player/:0:5","tags":["hugo","tech","asciinema"],"title":"如何在Hugo博客中使用终端播放器Asciinema-Player","uri":"/posts/2022/08/28/hugo-asciinema-player/"},{"categories":null,"content":"个人简介 姓名：王诚强 昵称：whitefirer、mortywang、strcat、一只流浪猫 🔭 我正在 腾讯 工作，研究并开发基础架构、云原生、服务网格，同时是Aeraki-Mesh的Maitainer； 🌱 我正在努力学习以成为优秀的 云原生开发者、 基础架构工程师、 架构师、技术管理者； 👯 我热衷为伟大的项目积极做出贡献，或者说想创造伟大的项目； 💬 可以与我一起探讨 云原生 、 架构设计、乃至一切 有趣的技术 😄； ⚡ 显而易见: 我是一名 GEEK； 联系方式：发邮件给我 或者以下方式↓ ","date":"2022-08-21","objectID":"/about/:0:1","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"演讲和讲义 OpenTalk演讲：荔枝微课基础架构的演进与实践 腾讯云云原生大会：荔枝微课基于 Kubernetes 搭建分布式压测系统 IstioCon 2022分享: Istio + Aeraki 在腾讯音乐的服务网格落地 ","date":"2022-08-21","objectID":"/about/:0:2","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"荣誉 🏆 2020年荣获荔枝微课S级贡献员工称号（公司级最高荣誉） 🏆 2022年腾讯新代码文化团队金奖（集团公司级，Aeraki Mesh Team） 🥇 2022年腾讯新代码文化个人奖（集团公司级，每团队一名额，Aeraki Mesh Maintainer） ","date":"2022-08-21","objectID":"/about/:0:3","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"自我评价 十年从业经验，阅历丰富，有着创业经历，从0到1实现了云原生和基础架构改造，也从0到1搭建过团队，并富有创造力，能够从全局出发考虑问题，抓住稳定和高效的重点，并实际推进落地，具有Geek精神，对新技术保持学习热情，关注CNCF社区的发展，热衷于开源事业，学习并参与开源项目的开发，不断在与他人的交流中获得灵感共同进步。 编程语言 开发框架 数据库\u0026组件 常用工具 休闲平台 操作系统 ","date":"2022-08-21","objectID":"/about/:0:4","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"微信扫码 ","date":"2022-08-21","objectID":"/about/:0:5","tags":null,"title":"关于我","uri":"/about/"}]